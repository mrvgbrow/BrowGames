#!/c/Users/sp4ce/AppData/Local/Programs/Python/Python310/python

import sys

exec_run=False
if getattr(sys,'frozen', False):
    os.chdir(sys._MEIPASS)
    exec_run=True

import os
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = 'hide' 
#os.environ['SDL_VIDEO_WINDOW_POS']="%d,%d" % (0,0)
import pygame
import menu
import presets
import player
import curved_paddle
import random
import math
import datetime
import ball
import wall
import gameconstants as gc


# Initialize the game, music, timer, and screen
pygame.init()
pygame.font.init()
pygame.mixer.music.load("ding.mp3")
clock=pygame.time.Clock()
presets_dict=presets.load_presets()
preset_default='Standard'
presets.set_preset(presets_dict[preset_default])
screen = pygame.display.set_mode([gc.SCREEN_WIDTH, gc.SCREEN_HEIGHT])
menu_run=True
while menu_run:
    menu_run,preset_out=menu.run_menu('Pong',screen,presets_dict,preset_default)
gc.scale_parameters()
current_settings=presets.get_settings()

font=pygame.font.Font("pong-score-extended.ttf",gc.FONT_SIZE)
pygame.mixer.music.set_volume(gc.SOUND_VOLUME)
all_sprites = pygame.sprite.Group()
players = pygame.sprite.Group()
screen = pygame.display.set_mode([gc.SCREEN_WIDTH, gc.SCREEN_HEIGHT])

# Create the player and ball sprites, add them to sprite groups for 
# ease of processing.
n_players=2
for player_i in range(n_players):
    player_x_position=current_settings['PLAYER'+str(player_i+1)+"_X_POSITION"]
    player_color=current_settings['PLAYER'+str(player_i+1)+"_COLOR"]
    player_control=current_settings['PLAYER'+str(player_i+1)+"_CONTROL"]
    if gc.CURVED_PADDLE:
        player_o=curved_paddle.CurvedPaddle(player_x_position,player_color,player_i+1,player_control)
    else:
        player_o=player.Player(player_x_position,player_color,player_i+1,player_control)
    players.add(player_o)
    all_sprites.add(player_o)


balls=pygame.sprite.Group()
for i in range(gc.BALL_NUMBER):
    ball_i=ball.Ball()
    balls.add(ball_i)
    all_sprites.add(ball_i)

top_wall=wall.Wall("top",gc.SCREEN_WIDTH/2,gc.WALL_WIDTH/2,gc.SCREEN_WIDTH,gc.WALL_WIDTH)
bottom_wall=wall.Wall("bottom",gc.SCREEN_WIDTH/2,gc.SCREEN_HEIGHT-gc.WALL_WIDTH/2,gc.SCREEN_WIDTH,gc.WALL_WIDTH)
sub_wall_size=(gc.SCREEN_HEIGHT-2*gc.WALL_WIDTH-gc.GOAL_SIZE)/2+gc.WALL_WIDTH
bottom_left_wall=wall.Wall("bottom left",gc.WALL_WIDTH/2,gc.SCREEN_HEIGHT-sub_wall_size/2,gc.WALL_WIDTH,sub_wall_size)
top_left_wall=wall.Wall("top left",gc.WALL_WIDTH/2,sub_wall_size/2,gc.WALL_WIDTH,sub_wall_size)
bottom_right_wall=wall.Wall("bottom right",gc.SCREEN_WIDTH-gc.WALL_WIDTH/2,gc.SCREEN_HEIGHT-sub_wall_size/2,gc.WALL_WIDTH,sub_wall_size)
top_right_wall=wall.Wall("top right",gc.SCREEN_WIDTH-gc.WALL_WIDTH/2,sub_wall_size/2,gc.WALL_WIDTH,sub_wall_size)
if gc.GOAL_SIZE<gc.SCREEN_HEIGHT:
    walls=[top_wall,bottom_wall,bottom_left_wall,bottom_right_wall,top_left_wall,top_right_wall]
    all_sprites.add(top_wall,bottom_wall,bottom_left_wall,top_left_wall,bottom_right_wall,top_right_wall)
else:
    walls=[top_wall,bottom_wall]
    all_sprites.add(top_wall,bottom_wall)

# Initialize variables
running = True    # Flag indicating when to stop the game
total_time=0      
score=[0,0]
pause=False
step=False
center_line_width=2
n_dash_center_line=30
time_ref=0
time_ref=1
ball_wait=False
ball_position_array=[]
reset=False
debug_string=''
game_state=0

while running:

    # Did the user click the window close button?
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == gc.KEYDOWN:
            if event.key == gc.K_ESCAPE:
                running = False
            if event.key == gc.K_p:
                if pause:
                    pause=False
                else:
                    pause=True
            if event.key == gc.K_RIGHTBRACKET:
                step=True
            if event.key == gc.K_r:
                reset=True
            if event.key == gc.K_DELETE and not exec_run:
                os.execl(sys.executable,f'"{sys.executable}"',*sys.argv)

    # If paused, continuously skip over the game loop (except event processing).
    # If taking one step through the loop, don't pause but unset the step
    # immediately after.
    if pause and not step:
        pygame.time.delay(16)
        continue
    if step:
        step=False

    pressed_keys = pygame.key.get_pressed()

    # For each ball, determine the position where the it will intersect with
    # the horizontal positions of player 1 and player 2. This is used by the
    # AI to decide where to move.
    for ball_i in balls:
        if ball_i.speedx>0:
            intercept=gc.PLAYER2_X_POSITION
        else:
            intercept=gc.PLAYER1_X_POSITION
        kill_case=ball_i.update(intercept)
        if kill_case==-1:
            score[1]+=1
            ball_i.kill()
        elif kill_case==1:
            score[0]+=1
            ball_i.kill()
        for side in range(2):
            if score[side]>=gc.SCORE_MAX:
                win_text=font.render('Player '+str(side+1)+' Wins!',True,(255,255,255))
                game_state=1
                time_ref_1=total_time


        ball_position_array.append((ball_i.x,ball_i.y))


    # Always allow player movement when human controlled. Only update the AI position when the ball is moving towards it.
    for player in players:
        player_side=1 if player.rect.centerx < gc.SCREEN_WIDTH/2 else 2
        ball_side=1 if ball_i.speedx<0 else 2
        if not (ball_side!=player_side and player.control == 'computer'):
            player.update(pressed_keys,ball_i.intercept,ball_i.speedy)


    # Fill the background
    screen.fill(gc.SCREEN_COLOR)

    # Render all sprites on the screen
    for entity in all_sprites:
        screen.blit(entity.surf,entity.rect)

    # Render the score, if requested 
    if not gc.SCORE_HIDE:
#        score_text=font.render(f'Player1: {score[0]}  Player2: {score[1]}',True,(255,255,255))
        score_text1=font.render(f'{score[0]}',True,(255,255,255))
        score_text2=font.render(f'{score[1]}',True,(255,255,255))
#        screen.blit(score_text, (gc.SCORE_XPOS,gc.SCORE_YPOS))
        screen.blit(score_text1, (0.23*gc.SCREEN_WIDTH,gc.SCORE_YPOS))
        screen.blit(score_text2, (0.73*gc.SCREEN_WIDTH,gc.SCORE_YPOS))

    # Render the clock, if requested
    if not gc.TIME_HIDE:
        rounded_time=float(int(total_time*100))/100.0
        time_text=font.render(f'Time: {rounded_time}',True,(255,255,255))
        screen.blit(time_text, (gc.TIME_XPOS,gc.TIME_YPOS))

#    debug_string=f'{ball_i.intercept:.1f} {player1.target:.1f} {gc.PLAYER_HEIGHT}'
    if debug_string != '':
        debug_text=font.render(debug_string,True,(255,255,255))
        screen.blit(debug_text, (gc.SCREEN_HEIGHT/2,gc.SCREEN_WIDTH/2))


    if gc.SHOW_BALL_TRAIL:
        for ball_position in ball_position_array:
            if ball_position[0]>0 and ball_position[1]>0:
                pygame.draw.circle(screen, (255,255,255),ball_position,1)

    if not gc.CENTER_LINE_HIDE:
        for center_count in range(n_dash_center_line):
            y_pos=gc.SCREEN_HEIGHT/n_dash_center_line*center_count
            pygame.draw.rect(screen,(255,255,255),(gc.SCREEN_WIDTH/2-center_line_width/2,y_pos,center_line_width,gc.SCREEN_HEIGHT/n_dash_center_line/2))

    # Check whether any balls are colliding with a player. If so, compute
    # the bounce angle and change the active player
    for player_object in players:
        balls_hit=pygame.sprite.spritecollide(player_object, balls,False,collided=pygame.sprite.collide_mask)
        if balls_hit:
            for ball_hit in balls_hit:
                if ball_hit.player_hit!=player_object.player_id:
                    pygame.mixer.music.play(loops=1)
                    direction='right' if ball_hit.speedx<0 else 'left'
                    anglesign=1 if ball_hit.speedx<0 else -1
                    if gc.ORIGINAL_BOUNCE:
                      new_angle=player_object.compute_original_angle(ball_hit.rect.centery,ball_hit.speedx)
                      ball_hit.set_angle(new_angle)
                    else:
                      ball_hit.bounce_wall(direction)
                      anglechange=anglesign*player_object.compute_anglechange(ball_hit.rect.centery)
                      ball_hit.anglechange(anglechange)
                    player_object.target=gc.SCREEN_HEIGHT*random.random()
                    ball_hit.player_hit=player_object.player_id

    # Check whether any balls are colliding with the walls
    for this_wall in walls:
        balls_hit=pygame.sprite.spritecollide(this_wall, balls,False,collided=pygame.sprite.collide_mask)
        for ball_hit in balls_hit:
            pygame.mixer.music.play(loops=1)
            ball_hit.player_hit=0
            if this_wall.name=="top":
                ball_hit.bounce_wall("down")
            elif this_wall.name=="bottom":
                ball_hit.bounce_wall("up")
            elif "left" in this_wall.name:
                ball_hit.bounce_wall("right")
            elif "right" in this_wall.name:
                ball_hit.bounce_wall("left")

    # If no balls remain on the field, increment the score for the player
    # whose turn it *isn't*
    if not balls and game_state==0:

        ball_position_array=[]
        # This code is used for testing different ball trajectories
#        for i in range(1):
#          ball_0=ball.Ball()
#          vertical_shift=-gc.PLAYER_HEIGHT/3.35+float(score_side2+score_side1)*gc.PLAYER_HEIGHT/10
#          ball_0.shoot((player1.rect.centerx,player1.rect.centery-gc.PLAYER_HEIGHT/1.7),10,300,210)
#          balls.add(ball_0)
#          all_sprites.add(ball_0)

        if time_ref<total_time and not ball_wait:
            time_ref=total_time
            ball_wait=True
        if total_time-time_ref>gc.BALL_WAIT and ball_wait:
            ball_wait=False
            ball_0=ball.Ball()
            balls.add(ball_0)
            all_sprites.add(ball_0)

    if game_state==1:
        screen.blit(win_text, (gc.SCREEN_WIDTH/2-win_text.get_width()/2,gc.SCREEN_HEIGHT*0.53-win_text.get_height()/2))
        if total_time-time_ref_1>3:
            running=False

    if reset:
        score[0]=0
        score[1]=0
        reset=False

    # Update the display
    pygame.display.flip()

    clock.tick(gc.TICK_FRAMERATE)
    total_time=total_time+1/gc.TICK_FRAMERATE

# Print the game time and score to a table to keep track of high scores
original_stdout = sys.stdout
with open('scores.dat','a') as f:
    sys.stdout = f
    print('%s, Player1 (%s): %d,  Player2 (%s): %d,  Game Time: %.2f seconds' % (datetime.datetime.now(),gc.PLAYER1_CONTROL,score[0],gc.PLAYER2_CONTROL,score[1],total_time))
    sys.stdout=original_stdout

# Stop the sound effects
pygame.mixer.music.stop()
pygame.mixer.quit()

# Done! Time to quit.
pygame.quit()

